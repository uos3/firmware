'''
Generate CRC tables for Crypto module
'''

import os
from pathlib import Path
from pprint import pprint
from datetime import datetime
from pprint import pprint

def main():
    '''
    Run the generation process
    '''

    print('Starting Crypto CRC table generation')

    # Get the root dir of OBC-Firmware
    root_dir = Path(__file__).parent.absolute()
    root_dir = root_dir.parent.parent.parent

    # Change into src
    src_dir = root_dir.joinpath('src')
    os.chdir(src_dir)

    # Get table for 32 bit, in a CRC-32C format. This is the CRC used by SCTP
    # and shows better error correction capability over standard CRC-32 (IEEE).
    crc32_table = get_crc_table(32, 0x1EDC6F41)

    # Get the 16 bit table, using CRC-16/CCITT-FALSE polynomial, as used by
    # ECSS-E-ST-70-41C. 
    crc16_table = get_crc16_ccitt_table()

    gen_table_file(crc32_table, crc16_table)

def get_crc_table(width, polynomial):
    '''
    Compute the CRC table for 32 bit CRCs.

    Based on
    https://barrgroup.com/embedded-systems/how-to/crc-calculation-c-code
    and https://medium.com/@chenfelix/crc32c-algorithm-79e0a7e33f61
    '''

    # Reflect the polynomial
    reflect_poly = reflect(polynomial, width)

    # List of 256 zeros to start with
    table = [0] * 256

    # For each entry in the table
    for i in range(256):
        # Start with the dividend (i)
        crc = i

        # Modulo-2 division, 1 bit at a time
        for j in range(8, 0, -1):
            # Try to divide the current data bit
            if (crc & 1):
                crc = (crc >> 1) ^ reflect_poly
            else:
                crc = (crc >> 1)

        # Store result in table
        table[i] = crc

    # Return the table
    return table

def get_crc16_ccitt_table():
    '''
    Compute the CRC16-CCITT table based on ECSS-E-ST-70-41C, B1.6
    '''

    table = [0]*256

    for i in range(256):
        crc = 0
        xor_1 = 0x1021
        xor_2 = 0x1231

        for j in range(8):
            if (i & (1 << j)) != 0:
                xor = (xor_1 << j) if j < 4 else (xor_2 << j - 4)
                crc = crc ^ xor
        
        table[i] = crc

    return table

def reflect(x, width):
    '''
    Reflect the given value
    '''
    b = '{:0{width}b}'.format(x, width=width)
    return int(b[::-1], 2)

def gen_table_file(crc32_table, crc16_table):
    '''
    Generate the table source file
    '''
    newline = '\n'

    lines32 = [
        f'    0x{a:08X}, 0x{b:08X}, 0x{c:08X}, 0x{d:08X},' 
        for a, b, c, d in chunks(crc32_table, 4)
    ]
    lines32[-1] = lines32[-1][:-1]

    lines16 = [
        f'    0x{a:04X}, 0x{b:04X}, 0x{c:04X}, 0x{d:04X},' 
        for a, b, c, d in chunks(crc16_table, 4)
    ]
    lines16[-1] = lines16[-1][:-1]

    source = \
f'''
/**
 * @file Crypto_crc_tables.c
 * @author Duncan Hamill (dh2g16@soton.ac.uk/duncanrhamill@googlemail.com)
 * @brief Generated CRC tables for crypto module.
 *
 * This file was generated by Crypto_gen_crc_tables.py.
 * 
 * @version 0.1
 * @date {datetime.today().strftime("%Y-%m-%d")}
 * 
 * @copyright Copyright (c) UoS3 2020
 */

/* -------------------------------------------------------------------------   
 * INCLUDES
 * ------------------------------------------------------------------------- */

/* Internal includes */
#include "util/crypto/Crypto_public.h"
#include "util/crypto/Crypto_private.h"

/* -------------------------------------------------------------------------   
 * GLOBALS
 * ------------------------------------------------------------------------- */

const Crypto_Crc32 CRYPTO_CRC32_TABLE[256] = {{
{newline.join(lines32)}
}};

const Crypto_Crc16 CRYPTO_CRC16_TABLE[256] = {{
{newline.join(lines16)}
}};
'''

    with open('util/crypto/Crypto_crc_tables.c', 'w+') as file:
        file.write(source)

def chunks(lst, n):
    """Yield successive n-sized chunks from lst."""
    for i in range(0, len(lst), n):
        yield lst[i:i + n]

if __name__ == '__main__':
    main()