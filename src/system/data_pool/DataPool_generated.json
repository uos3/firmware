{
    "DP.INITIALISED": {
        "block_id": 0,
        "block_index": 1,
        "dp_id": 1,
        "data_type": "bool",
        "brief": "Flag set to true if the DataPool has been initialised, false if otherwise."
    },
    "DP.BOARD_INITIALISED": {
        "block_id": 0,
        "block_index": 2,
        "dp_id": 2,
        "data_type": "bool",
        "brief": "Flag set to true if the Board driver has been initialised, false otherwise."
    },
    "DP.RTC_INITIALISED": {
        "block_id": 0,
        "block_index": 3,
        "dp_id": 3,
        "data_type": "bool",
        "brief": "Flag set if the Rtc driver has been initialised."
    },
    "DP.EVENTMANAGER.INITIALISED": {
        "block_id": 3,
        "block_index": 1,
        "dp_id": 3073,
        "data_type": "bool",
        "brief": "Flag indicating whether or not the EventManager has been  initialised."
    },
    "DP.EVENTMANAGER.ERROR_CODE": {
        "block_id": 3,
        "block_index": 2,
        "dp_id": 3074,
        "data_type": "ErrorCode",
        "brief": "Stores an error code coming from the EventManager."
    },
    "DP.EVENTMANAGER.MAX_EVENTS_REACHED": {
        "block_id": 3,
        "block_index": 3,
        "dp_id": 3075,
        "data_type": "bool",
        "brief": "Flag which is true if the maximum number of events have been raised, indicating that some events may be missed."
    },
    "DP.EVENTMANAGER.NUM_RAISED_EVENTS": {
        "block_id": 3,
        "block_index": 4,
        "dp_id": 3076,
        "data_type": "uint16_t",
        "brief": "Counter storing the number of raised events."
    },
    "DP.EVENTMANAGER.EVENT_LIST_SIZE": {
        "block_id": 3,
        "block_index": 5,
        "dp_id": 3077,
        "data_type": "size_t",
        "brief": "The current size of the allocated event lists."
    },
    "DP.IMU.INITIALISED": {
        "block_id": 37,
        "block_index": 1,
        "dp_id": 37889,
        "data_type": "bool",
        "brief": "Flag indicating whether or not the Imu has been initialised."
    },
    "DP.IMU.ERROR_CODE": {
        "block_id": 37,
        "block_index": 2,
        "dp_id": 37890,
        "data_type": "ErrorCode",
        "brief": "Stores errors that occur during operation."
    },
    "DP.IMU.I2C_ERROR_CODE": {
        "block_id": 37,
        "block_index": 3,
        "dp_id": 37891,
        "data_type": "ErrorCode",
        "brief": "Stores errors from the I2C module."
    },
    "DP.IMU.STATE": {
        "block_id": 37,
        "block_index": 4,
        "dp_id": 37892,
        "data_type": "Imu_State",
        "brief": "IMU state machine state."
    },
    "DP.IMU.SUBSTATE": {
        "block_id": 37,
        "block_index": 5,
        "dp_id": 37893,
        "data_type": "Imu_SubState",
        "brief": "IMU state machine substate."
    },
    "DP.IMU.COMMAND": {
        "block_id": 37,
        "block_index": 6,
        "dp_id": 37894,
        "data_type": "Imu_Command",
        "brief": "Command the Imu module shall execute."
    },
    "DP.IMU.GYROSCOPE_DATA": {
        "block_id": 37,
        "block_index": 7,
        "dp_id": 37895,
        "data_type": "Imu_VecInt16",
        "brief": "Data from the IMU's gyroscope."
    },
    "DP.IMU.GYROSCOPE_DATA_VALID": {
        "block_id": 37,
        "block_index": 8,
        "dp_id": 37896,
        "data_type": "bool",
        "brief": "True when the data contained in DP.IMU.GYROSCOPE_DATA is valid."
    },
    "DP.IMU.MAGNETOMETER_DATA": {
        "block_id": 37,
        "block_index": 9,
        "dp_id": 37897,
        "data_type": "Imu_VecInt16",
        "brief": "Data from the IMU's magnetometer."
    },
    "DP.IMU.MAGNE_SENSE_ADJUST_DATA": {
        "block_id": 37,
        "block_index": 10,
        "dp_id": 37898,
        "data_type": "Imu_VecUint8",
        "brief": "Sensetivity adjustment data from the magnetometer."
    },
    "DP.IMU.MAGNETOMETER_DATA_VALID": {
        "block_id": 37,
        "block_index": 11,
        "dp_id": 37899,
        "data_type": "bool",
        "brief": "True when the data contained in DP.IMU.MAGNETOMETER_DATA is valid."
    },
    "DP.IMU.TEMPERATURE_DATA": {
        "block_id": 37,
        "block_index": 12,
        "dp_id": 37900,
        "data_type": "int16_t",
        "brief": "Temperature reading from the IMU."
    },
    "DP.IMU.TEMPERATURE_DATA_VALID": {
        "block_id": 37,
        "block_index": 13,
        "dp_id": 37901,
        "data_type": "bool",
        "brief": "True when the data contained in DP.IMU.TEMPERATURE_DATA is valid."
    },
    "DP.MEMSTOREMANAGER.INITIALISED": {
        "block_id": 4,
        "block_index": 1,
        "dp_id": 4097,
        "data_type": "bool",
        "brief": "Flag indicating whether or not the MemStoreManager is initialised."
    },
    "DP.MEMSTOREMANAGER.ERROR_CODE": {
        "block_id": 4,
        "block_index": 2,
        "dp_id": 4098,
        "data_type": "ErrorCode",
        "brief": "Error code for the MemStoreManager"
    },
    "DP.MEMSTOREMANAGER.EEPROM_ERROR_CODE": {
        "block_id": 4,
        "block_index": 3,
        "dp_id": 4099,
        "data_type": "ErrorCode",
        "brief": "Error code from the EEPROM driver."
    },
    "DP.MEMSTOREMANAGER.CFG_FILE_1_OK": {
        "block_id": 4,
        "block_index": 4,
        "dp_id": 4100,
        "data_type": "bool",
        "brief": "Indicates if the first configuration file is OK."
    },
    "DP.MEMSTOREMANAGER.CFG_FILE_2_OK": {
        "block_id": 4,
        "block_index": 5,
        "dp_id": 4101,
        "data_type": "bool",
        "brief": "Indicates if the second configuration file is OK."
    },
    "DP.MEMSTOREMANAGER.CFG_FILE_3_OK": {
        "block_id": 4,
        "block_index": 6,
        "dp_id": 4102,
        "data_type": "bool",
        "brief": "Indicates if the third configuration file is OK."
    },
    "DP.MEMSTOREMANAGER.USE_BACKUP_CFG": {
        "block_id": 4,
        "block_index": 7,
        "dp_id": 4103,
        "data_type": "bool",
        "brief": "Flag which can be set during the boot process if the EEPROM is not functioning, and therefore we must use the redundent config stored as apart of the software image."
    },
    "DP.MEMSTOREMANAGER.PERS_DATA_DIRTY": {
        "block_id": 4,
        "block_index": 8,
        "dp_id": 4104,
        "data_type": "bool",
        "brief": "Flag which indicates that the persistent data has been modified since the previous call to MemStoreManager_step, and should be written to the EEPROM."
    },
    "DP.MEMSTOREMANAGER.PERS_FILE_1_OK": {
        "block_id": 4,
        "block_index": 9,
        "dp_id": 4105,
        "data_type": "bool",
        "brief": "Indicates if the first persistent file is OK."
    },
    "DP.MEMSTOREMANAGER.PERS_FILE_2_OK": {
        "block_id": 4,
        "block_index": 10,
        "dp_id": 4106,
        "data_type": "bool",
        "brief": "Indicates if the second persistent file is OK."
    },
    "DP.MEMSTOREMANAGER.PERS_FILE_3_OK": {
        "block_id": 4,
        "block_index": 11,
        "dp_id": 4107,
        "data_type": "bool",
        "brief": "Indicates if the third persistent file is OK."
    },
    "DP.EPS.INITIALISED": {
        "block_id": 34,
        "block_index": 1,
        "dp_id": 34817,
        "data_type": "bool",
        "brief": "Flag indicating whether or not the Eps has been initialised."
    },
    "DP.EPS.ERROR_CODE": {
        "block_id": 34,
        "block_index": 2,
        "dp_id": 34818,
        "data_type": "ErrorCode",
        "brief": "Stores errors that occur during operation."
    },
    "DP.EPS.STATE": {
        "block_id": 34,
        "block_index": 3,
        "dp_id": 34819,
        "data_type": "Eps_State",
        "brief": "The current state of the Eps module."
    },
    "DP.EPS.CONFIG_SYNCED": {
        "block_id": 34,
        "block_index": 4,
        "dp_id": 34820,
        "data_type": "bool",
        "brief": "Indicates if the configuration of the EPS is synchronised (matches with) the config specified in the OBC's config file."
    },
    "DP.EPS.NEW_REQUEST": {
        "block_id": 34,
        "block_index": 5,
        "dp_id": 34821,
        "data_type": "bool",
        "brief": "Flag indicating that there's a new request to send to the EPS."
    },
    "DP.EPS.EPS_REQUEST[EPS_MAX_UART_FRAME_LENGTH]": {
        "block_id": 34,
        "block_index": 6,
        "dp_id": 34822,
        "data_type": "uint8_t",
        "brief": "The request (command) to be sent in EPS_STATE_REQUEST."
    },
    "DP.EPS.EPS_REQUEST_LENGTH": {
        "block_id": 34,
        "block_index": 7,
        "dp_id": 34823,
        "data_type": "size_t",
        "brief": "Length of the request stored in DP.EPS.EPS_REQUEST."
    },
    "DP.EPS.EPS_REPLY[EPS_MAX_UART_FRAME_LENGTH]": {
        "block_id": 34,
        "block_index": 8,
        "dp_id": 34824,
        "data_type": "uint8_t",
        "brief": "The reply from the EPS."
    },
    "DP.EPS.EPS_REPLY_LENGTH": {
        "block_id": 34,
        "block_index": 9,
        "dp_id": 34825,
        "data_type": "size_t",
        "brief": "Length of the reply stored in DP.EPS.EPS_REPLY"
    },
    "DP.EPS.UART_FRAME_NUMBER": {
        "block_id": 34,
        "block_index": 10,
        "dp_id": 34826,
        "data_type": "uint8_t",
        "brief": "Frame number of the latest UART frame to be sent."
    },
    "DP.EPS.COMMAND_STATUS": {
        "block_id": 34,
        "block_index": 11,
        "dp_id": 34827,
        "data_type": "Eps_CommandStatus",
        "brief": "The status of the most recently sent command."
    },
    "DP.EPS.HK_DATA": {
        "block_id": 34,
        "block_index": 12,
        "dp_id": 34828,
        "data_type": "Eps_HkData",
        "brief": "Most up-to-date housekeeping data returned by the EPS."
    },
    "DP.POWER.INITIALISED": {
        "block_id": 53,
        "block_index": 1,
        "dp_id": 54273,
        "data_type": "bool",
        "brief": "Indicates if the Power app is initialised (true) or not (false)."
    },
    "DP.POWER.ERROR_CODE": {
        "block_id": 53,
        "block_index": 2,
        "dp_id": 54274,
        "data_type": "ErrorCode",
        "brief": "Stores error codes that occur during operation."
    },
    "DP.POWER.TIMER_ERROR_CODE": {
        "block_id": 53,
        "block_index": 3,
        "dp_id": 54275,
        "data_type": "ErrorCode",
        "brief": "Stores error codes returned by the Timer driver."
    },
    "DP.POWER.LOW_POWER_MODE_REQUEST": {
        "block_id": 53,
        "block_index": 4,
        "dp_id": 54276,
        "data_type": "bool",
        "brief": "Flag indicating whether or not Mission is requested to transition into Low Power (LP) OpMode."
    },
    "DP.POWER.TASK_TIMER_EVENT": {
        "block_id": 53,
        "block_index": 5,
        "dp_id": 54277,
        "data_type": "Event",
        "brief": "The event associated with the app's primary task timer."
    },
    "DP.POWER.REQUESTED_OCP_STATE": {
        "block_id": 53,
        "block_index": 6,
        "dp_id": 54278,
        "data_type": "Eps_OcpState",
        "brief": "The requested state of the OCP rails, which is based on the OpMode and the stored OpMode-OCP state configuration vector."
    },
    "DP.POWER.UPDATE_EPS_HK": {
        "block_id": 53,
        "block_index": 7,
        "dp_id": 54279,
        "data_type": "bool",
        "brief": "Flag which when true will cause the Power app to request a new EPS HK packet from the EPS outside of the standard task operation. See Power_request_eps_hk()."
    },
    "DP.POWER.UPDATE_EPS_CFG": {
        "block_id": 53,
        "block_index": 8,
        "dp_id": 54280,
        "data_type": "bool",
        "brief": ""
    },
    "DP.POWER.UPDATE_EPS_OCP_STATE": {
        "block_id": 53,
        "block_index": 9,
        "dp_id": 54281,
        "data_type": "bool",
        "brief": "Flag which when true will cause the Power app to send an updated OCP state to the EPS."
    },
    "DP.POWER.LAST_EPS_COMMAND": {
        "block_id": 53,
        "block_index": 10,
        "dp_id": 54282,
        "data_type": "Eps_UartDataType",
        "brief": "The type of command which was last issued to the EPS."
    },
    "DP.POWER.NUM_CONSEC_FAILED_EPS_COMMANDS": {
        "block_id": 53,
        "block_index": 11,
        "dp_id": 54283,
        "data_type": "uint8_t",
        "brief": "The number of consecutive EPS command failures. Used to detect possible malfunctions in the EPS."
    },
    "DP.POWER.EPS_OCP_STATE_CORRECT": {
        "block_id": 53,
        "block_index": 12,
        "dp_id": 54284,
        "data_type": "bool",
        "brief": "This flag shall be true if a command to set the EPS OCP state succeeds. If the EPS fails to return the expected OCP state, this will be false. It shall also be false from the time a OCP update is requested, until a successful update is detected."
    },
    "DP.POWER.OPMODE_CHANGE_IN_PROGRESS": {
        "block_id": 53,
        "block_index": 13,
        "dp_id": 54285,
        "data_type": "bool",
        "brief": "Flag which is true while the Power app is performing the actions needed to change OPMODE, namely:  - Updating the OCP state of the EPS."
    },
    "DP.OPMODEMANAGER.INITIALISED": {
        "block_id": 10,
        "block_index": 1,
        "dp_id": 10241,
        "data_type": "bool",
        "brief": "Flag indicating if the OpModeManager App has been initialised (true) or not (false)."
    },
    "DP.OPMODEMANAGER.ERROR_CODE": {
        "block_id": 10,
        "block_index": 2,
        "dp_id": 10242,
        "data_type": "ErrorCode",
        "brief": "Stores errors that occur during operation."
    },
    "DP.OPMODEMANAGER.STATE": {
        "block_id": 10,
        "block_index": 3,
        "dp_id": 10243,
        "data_type": "OpModeManager_State",
        "brief": "The current state of the OpModeManager."
    },
    "DP.OPMODEMANAGER.OPMODE": {
        "block_id": 10,
        "block_index": 4,
        "dp_id": 10244,
        "data_type": "OpModeManager_OpMode",
        "brief": "The current mission Operational Mode (OPMODE)"
    },
    "DP.OPMODEMANAGER.NEXT_OPMODE": {
        "block_id": 10,
        "block_index": 5,
        "dp_id": 10245,
        "data_type": "OpModeManager_OpMode",
        "brief": "The next OpMode that will be set when the current mode change is complete."
    },
    "DP.OPMODEMANAGER.TC_REQUEST_NEW_OPMODE": {
        "block_id": 10,
        "block_index": 6,
        "dp_id": 10246,
        "data_type": "bool",
        "brief": "Flag which will be raised by the TC handler responsible for accepting OpMode change TCs."
    },
    "DP.OPMODEMANAGER.GRACE_TRANS_STATE": {
        "block_id": 10,
        "block_index": 7,
        "dp_id": 10247,
        "data_type": "OpModeManager_GraceTransState",
        "brief": "The state of a graceful transition."
    },
    "DP.OPMODEMANAGER.GRACE_TRANS_TIMEOUT_EVENT": {
        "block_id": 10,
        "block_index": 8,
        "dp_id": 10248,
        "data_type": "Event",
        "brief": "The event associated with a graceful transition timeout."
    },
    "DP.OPMODEMANAGER.APP_IN_NEXT_MODE[OPMODEMANAGER_MAX_NUM_APPS_IN_MODE]": {
        "block_id": 10,
        "block_index": 9,
        "dp_id": 10249,
        "data_type": "bool",
        "brief": "Array, in which each element is true if it's corresponding app in the CFG.OPMODE_APPID_TABLE is present in the next mode. Calcualted once at the start of an OPMODE transition."
    },
    "DP.OPMODEMANAGER.BU_DWELL_TIMER_EVENT": {
        "block_id": 10,
        "block_index": 10,
        "dp_id": 10250,
        "data_type": "Event",
        "brief": "Event used to signal completion of the Dwell timer in BU mode"
    },
    "DP.OPMODEMANAGER.BU_DWELL_CHECK_RTC": {
        "block_id": 10,
        "block_index": 11,
        "dp_id": 10251,
        "data_type": "bool",
        "brief": "If true the BU_DWELL_TIMER_EVENT couldn't be set as the timer couldn't be started, therefore we will use the RTC instead."
    }
}